// Generated by the protocol buffer compiler , zqrpc plugin.  DO NOT EDIT!

#include "dqlib.zqrpc.h"
#include "dqlib.pb.h"
#include <google/protobuf/descriptor.h>
#include <google/protobuf/stubs/once.h>
#include <zqrpc.hpp>
namespace {
const ::google::protobuf::ServiceDescriptor* DQService_descriptor_ = NULL;
}  // anonymous namespace

namespace echo {

void zqrpc_protobuf_AssignDesc_dqlib_2eproto() {
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "dqlib.proto");
  GOOGLE_CHECK(file != NULL);
  DQService_descriptor_ = file->service(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &zqrpc_protobuf_AssignDesc_dqlib_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
}

}  // namespace

void zqrpc_protobuf_ShutdownFile_dqlib_2eproto() {
}

void zqrpc_protobuf_AddDesc_dqlib_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\013dqlib.proto\022\004echo\"\034\n\006Vector\022\022\n\004data\030\002 "
    "\003(\001R\004data\"\260\001\n\006Matrix\022\022\n\004rows\030\001 \001(\005R\004rows"
    "\022\022\n\004cols\030\002 \001(\005R\004cols\022\022\n\004data\030\003 \003(\001R\004data"
    "\022>\n\rstorage_order\030\004 \001(\0162\031.echo.Matrix.St"
    "orageOrderR\014storageOrder\"*\n\014StorageOrder"
    "\022\014\n\010RowMajor\020\000\022\014\n\010ColMajor\020\001\"\216\003\n\027MvoAsse"
    "tAllocationInput\022/\n\014asset_return\030\001 \001(\0132\014"
    ".echo.MatrixR\013assetReturn\022\032\n\010strategy\030\002 "
    "\001(\tR\010strategy\022\037\n\013target_type\030\003 \001(\tR\ntarg"
    "etType\022-\n\013lower_bound\030\004 \001(\0132\014.echo.Vecto"
    "rR\nlowerBound\022-\n\013upper_bound\030\005 \001(\0132\014.ech"
    "o.VectorR\nupperBound\022!\n\014target_value\030\006 \001"
    "(\001R\013targetValue\022/\n\023annualization_scale\030\007"
    " \001(\001R\022annualizationScale\022/\n\024num_returns_"
    "for_mean\030\010 \001(\005R\021numReturnsForMean\022\"\n\rnum"
    "_ef_points\030\t \001(\005R\013numEfPoints\"e\n\030MvoAsse"
    "tAllocationOutput\022&\n\007weights\030\001 \001(\0132\014.ech"
    "o.VectorR\007weights\022!\n\014target_value\030\002 \001(\001R"
    "\013targetValue2X\n\tDQService\022K\n\nCLAService\022"
    "\035.echo.MvoAssetAllocationInput\032\036.echo.Mv"
    "oAssetAllocationOutputb\006proto3", 830);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "dqlib.proto", &protobuf_RegisterTypes);
  ::google::protobuf::internal::OnShutdown(&zqrpc_protobuf_ShutdownFile_dqlib_2eproto);
}

// ===================================================================

DQService::~DQService() {}

const ::google::protobuf::ServiceDescriptor* DQService::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DQService_descriptor_;
}

const ::google::protobuf::ServiceDescriptor* DQService::GetDescriptor() {
  protobuf_AssignDescriptorsOnce();
  return DQService_descriptor_;
}

void DQService::CLAService(const ::echo::MvoAssetAllocationInput* request,
                         ::echo::MvoAssetAllocationOutput* response) {
  throw ::zqrpc::ZError(::zqrpc::ZEC_METHODNOTIMPLEMENTED,
              "Method CLAService() not implemented.");
}

void DQService::CallMethod(const ::google::protobuf::MethodDescriptor* method,
                             const ::google::protobuf::Message* request,
                             ::google::protobuf::Message* response) {
  GOOGLE_DCHECK_EQ(method->service(), DQService_descriptor_);
  switch(method->index()) {
    case 0:
      CLAService(
          ::google::protobuf::down_cast<const ::echo::MvoAssetAllocationInput*>(request),
          ::google::protobuf::down_cast< ::echo::MvoAssetAllocationOutput* >(response) );
      break;
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      break;
  }
}

const ::google::protobuf::Message& DQService::GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::echo::MvoAssetAllocationInput::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *reinterpret_cast< ::google::protobuf::Message*>(NULL);
  }
}

const ::google::protobuf::Message& DQService::GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::echo::MvoAssetAllocationOutput::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *reinterpret_cast< ::google::protobuf::Message*>(NULL);
  }
}

DQService_Stub::DQService_Stub(::zqrpc::RpcChannel* channel)
  : channel_(channel) {}
DQService_Stub::~DQService_Stub() {}

void DQService_Stub::CLAService(::zqrpc::ZController* controller,
                     ::echo::MvoAssetAllocationInput* request,
                     ::echo::MvoAssetAllocationOutput* response,
                     long deadline_ms){
  CLAService_Send(controller,request);
  CLAService_Recv(controller,response,deadline_ms);
}
void DQService_Stub::CLAService_Send(::zqrpc::ZController* controller,
                     ::echo::MvoAssetAllocationInput* request){
  channel_->ZSendMethod(DQService::descriptor()->method(0),
                        controller,
                        request);
}
void DQService_Stub::CLAService_Recv(::zqrpc::ZController* controller,
                     ::echo::MvoAssetAllocationOutput* response,
                     long deadline_ms){
  channel_->ZRecvMethod(controller,
                        response,
                        deadline_ms);
}

}  // namespace echo
